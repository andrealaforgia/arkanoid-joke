<!DOCTYPE html>
<html>
<head>
    <title>Arkanoid Game</title>
    <style>
        canvas {
          display: block;
          margin: 0 auto;
          border: 1px solid black;
        }
    </style>
</head>
<body>
<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
    const audio = new Audio("background_music.mp3")
    audio.volume = 0.1
    audio.loop = true

    setTimeout(() => {
        audio.play();
    }, 2000);

    const spriteSheet = new Image();
    spriteSheet.src = 'sprites.png';

    const hearts = new Image();
    hearts.src = 'hearts.png';

    const gameOver = new Image();
    gameOver.src = 'game_over.png';

    const canvas = document.getElementById("myCanvas");
    canvas.style.cursor = "none";

    const ctx = canvas.getContext("2d");

    // Brick properties
    const brickWidth = 40;
    const brickHeight = 40;
    const brickPadding = 0;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 30;

    // Set canvas size
    canvas.width = brickWidth * 32;
    canvas.height = brickWidth * 22;

    // Paddle properties
    const paddleWidth = 120;
    const paddleHeight = 33;
    let paddleX = (canvas.width - paddleWidth) / 2;
    let paddleY = canvas.height - paddleHeight;

    // Ball properties
    const ballRadius = 8;
    let x = paddleX + paddleWidth/2 - ballRadius;
    let y = paddleY - ballRadius*2;
    let dx = Math.random() < 0.5 ? 2 : -2;
    let dy = -2;
    let ballStatus = "OnPaddle"

    // Lives
    const MAX_LIVES = 3
    let lives = MAX_LIVES

    let gameState = "Playing"

    let bricks = [];

    function randomOffset() {
        const offsets = [0, 40, 120, 160, 200]
        const randomIndex = Math.floor(Math.random() * offsets.length);

        // Select the item at the random index
        return offsets[randomIndex];
    }

    // Create bricks
    function createBricks() {
        const brickSize = 40;
        const h_step = 34;
        const v_step = 34;
        const leftPadding = 10
        const topPadding = 10
        const hCharacterPadding = 20
        const vCharacterPadding = 20

        let text = []

        const F = {
            width: 4,
            bricks: [
                {x: 0, y:0}, {x: 1, y:0}, {x: 2, y:0}, {x: 3, y: 0},
                {x: 0, y:1},
                {x: 0, y:2},
                {x: 0, y:3}, {x: 1, y:3}, {x: 2, y: 3},
                {x: 0, y:4},
                {x: 0, y:5},
                {x: 0, y:6},
            ]
        }

        const A = {
            width: 4,
            bricks: [
                {x: 1, y:0}, {x: 2, y:0},
                {x: 0, y:1},{x: 3, y:1},
                {x: 0, y:2}, {x: 3, y:2},
                {x: 0, y:3}, {x: 1, y:3}, {x: 2, y: 3}, {x: 3, y: 3},
                {x: 0, y:4},{x: 3, y:4},
                {x: 0, y:5},{x: 3, y:5},
                {x: 0, y:6},{x: 3, y:6},
            ]
        }

        const B = {
            width: 4,
            bricks: [
                {x: 0, y:0}, {x: 1, y:0}, {x: 2, y:0},
                {x: 0, y:1}, {x: 3, y:1},
                {x: 0, y:2}, {x: 3, y:2},
                {x: 0, y:3}, {x: 1, y:3}, {x: 2, y: 3},
                {x: 0, y:4},{x: 3, y:4},
                {x: 0, y:5},{x: 3, y:5},
                {x: 0, y:6},{x: 1, y:6},{x: 2, y:6},
            ]
        }

        const I = {
            width: 1,
            bricks: [
                {x: 0, y:0},
                {x: 0, y:1},
                {x: 0, y:2},
                {x: 0, y:3},
                {x: 0, y:4},
                {x: 0, y:5},
                {x: 0, y:6},
            ]
        }

        const O = {
            width: 4,
            bricks:[
                {x: 1, y:0}, {x: 2, y:0},
                {x: 0, y:1}, {x: 3, y:1},
                {x: 0, y:2}, {x: 3, y:2},
                {x: 0, y:3}, {x: 3, y: 3},
                {x: 0, y:4},{x: 3, y:4},
                {x: 0, y:5},{x: 3, y:5},
                {x: 1, y:6},{x: 2, y:6},
            ]
        }

        const C = {
            width: 4,
            bricks:[
                {x: 1, y:0}, {x: 2, y:0},
                {x: 0, y:1}, {x: 3, y:1},
                {x: 0, y:2},
                {x: 0, y:3},
                {x: 0, y:4},
                {x: 0, y:5},{x: 3, y:5},
                {x: 1, y:6},{x: 2, y:6},
            ]
        }

        const Z = {
            width: 5,
            bricks:[
                {x: 0, y:0}, {x: 1, y:0}, {x: 0, y:0}, {x: 2, y:0}, {x: 3, y:0}, {x: 4, y: 0},
                {x: 4, y:1},
                {x: 3, y:2},
                {x: 2, y:3},
                {x: 1, y:4},
                {x: 0, y:5},
                {x: 0, y:6}, {x: 1, y:6}, {x: 0, y:6}, {x: 2, y:6}, {x: 3, y:6}, {x: 4, y: 6},
            ]
        }

        const N = {
            width: 5,
            bricks:[
                {x: 0, y:0}, {x: 4, y:0},
                {x: 0, y:1}, {x: 1, y: 1}, {x: 4, y:1},
                {x: 0, y:2}, {x: 2, y: 2}, {x: 4, y:2},
                {x: 0, y:3}, {x: 2, y: 3}, {x: 4, y:3},
                {x: 0, y:4}, {x: 3, y: 4}, {x: 4, y:4},
                {x: 0, y:5}, {x: 4, y:5},
                {x: 0, y:6}, {x: 4, y:6},
            ]
        }

        const E = {
            width: 4,
            bricks: [
                {x: 0, y:0}, {x: 1, y:0}, {x: 2, y:0}, {x: 3, y: 0},
                {x: 0, y:1},
                {x: 0, y:2},
                {x: 0, y:3}, {x: 1, y:3}, {x: 2, y: 3},
                {x: 0, y:4},
                {x: 0, y:5},
                {x: 0, y:6}, {x: 1, y:6}, {x: 2, y:6}, {x: 3, y: 6},
            ]
        }

        text[0] = [F, A, B, I, O]
        text[1] = [C, A, Z, Z, O, N, E]

        let i = 0, cursorY = 0
        for (let ty = 0; ty < text.length; ty++) {
            cursorX = 0;
            for (let tx = 0; tx < text[ty].length; tx++) {
                const charData = text[ty][tx]
                for (let cbi = 0; cbi < charData.bricks.length; cbi++) {
                    bricks[i++] = {
                        x: leftPadding + cursorX + charData.bricks[cbi].x * h_step,
                        y: topPadding + cursorY + charData.bricks[cbi].y * v_step,
                        status: 1,
                        spriteX: randomOffset(),
                        spriteY: 0
                    }
                }
                cursorX = cursorX + charData.width * h_step + hCharacterPadding
            }
            cursorY += 6 * brickSize + vCharacterPadding;
        }
    }

    function drawSprite(x, y, spriteWidth, spriteHeight, spriteX, spriteY) {
        ctx.drawImage(spriteSheet, spriteX, spriteY, spriteWidth, spriteHeight, x, y, spriteWidth, spriteHeight);
    }

    function drawLives() {
        const startX = canvas.width-31*MAX_LIVES
        for (let li=0; li<MAX_LIVES; li++) {
            if (li < lives) {
                ctx.drawImage(hearts, 2, 5, 28, 23, startX + li*30, 5, 28, 23);
            } else {
                ctx.drawImage(hearts, 66, 5, 28, 23, startX + li*30, 5, 28, 23);
            }
        }
    }

    function drawBricks() {
        for (let i = 0; i < bricks.length; i++) {
            if (bricks[i].status === 1) {
                ctx.beginPath();
                drawSprite(bricks[i].x, bricks[i].y, 40, 40, bricks[i].spriteX, bricks[i].spriteY);
                ctx.closePath();
            }
        }
    }

    function drawBall() {
        ctx.beginPath();
        drawSprite(x-ballRadius, y-ballRadius, ballRadius*2, ballRadius*2, 160, 200)
        ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
        drawSprite(paddleX, paddleY, 120, 33, 0, 240)
        ctx.closePath();
    }

    function drawBackground() {
        ctx.fillStyle = "#AAAAFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function playBallBrickCollisionSound() {
         const ballBrickSound = new Audio('ball_brick.mp3');
         ballBrickSound.play();
    }

    function playGameOverSound() {
         const gameOverSound = new Audio('game_over.mp3');
         gameOverSound.play();
    }

    function playFailureSound() {
         const failureSound = new Audio('failure.mp3');
         failureSound.play();
    }

    let gameOverStatusY = canvas.height

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawBackground();
        drawBricks();
        drawBall();
        drawPaddle();
        drawLives();

        if (gameState === "GameOver") {
            audio.pause();

            // Ensure the image doesn't go too far up
            if (gameOverStatusY > canvas.height / 2 - gameOver.height / 2) {
                gameOverStatusY -= 4;
            }

            ctx.drawImage(gameOver,
                0, 0, gameOver.width, gameOver.height,
                canvas.width/2-gameOver.width/2, gameOverStatusY, gameOver.width, gameOver.height
            );

        } else {
            // Ball movement
            if (ballStatus === "Moving") {
                x += dx;
                y += dy;

                // Ball and paddle collision
                if (y + dy >= paddleY && x >= paddleX && x <= paddleX + paddleWidth) {
                    y = paddleY - ballRadius
                    dy = -dy
                }

                if (y + dy < 0) {
                    y = ballRadius
                    dy = -dy

                } else if (y + dy > canvas.height) {
                    ballStatus = "OnPaddle"
                    if (--lives == 0) {
                        playGameOverSound()
                        gameState = "GameOver"

                    } else {
                        playFailureSound()
                    }
                }

                if (x + dx < 0) {
                    x = ballRadius
                    dx = -dx

                } else if (x + dx > canvas.width) {
                    x = canvas.width-ballRadius
                    dx = -dx
                }

                // Ball collision with bricks
                for (let i = 0; i < bricks.length; i++) {
                    const b = bricks[i];
                    if (b.status === 1) {
                        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            dy = -dy;
                            b.status = 0;
                            playBallBrickCollisionSound()
                        }
                    }
                }
            } else {
                x = paddleX + paddleWidth/2 - ballRadius
                y = paddleY - ballRadius
            }

            // Paddle movement
            document.addEventListener("mousemove", mouseMoveHandler, false);

            // Key events
            document.addEventListener('keydown', keyPressHandler, false);

            function keyPressHandler(e) {
                if (gameState === 'GameOver') {
                    return
                }
                switch (e.code) {
                    case 'Space':
                        if (ballStatus === "OnPaddle") {
                            dx = Math.random() < 0.5 ? 2 : -2;
                            dy = -2;
                            ballStatus = "Moving"
                        }
                        break;
                }
            }

            function mouseMoveHandler(e) {
                if (gameState === 'GameOver') {
                    return
                }
                const relativeX = e.clientX - canvas.offsetLeft;
                if (relativeX < 0) {
                    paddleX = 0
                } else if (relativeX >= canvas.width-paddleWidth) {
                    paddleX = canvas.width-1-paddleWidth
                } else {
                    paddleX = relativeX
                }
            }
        }
        requestAnimationFrame(draw);
    }

    createBricks();
    draw();
</script>
</body>
</html>